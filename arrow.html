<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>2D Free Fire Inspired Shooter with Virtual Buttons</title>
  <style>
    /* Prevent text selection */
    * {
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }
    body {
      margin: 0;
      overflow: hidden;
      background: #111;
    }
    canvas {
      display: block;
      background: #111;
    }
    /* Simple HUD overlay */
    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #fff;
      font-family: Arial, sans-serif;
      font-size: 20px;
      z-index: 100;
      pointer-events: none;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
    }
    /* Virtual control styling */
    #controls {
      position: absolute;
      bottom: 20px;
      left: 0;
      width: 100%;
      pointer-events: none; /* Container won’t block touches */
    }
    #movePad {
      position: absolute;
      bottom: 20px;
      left: 20px;
      pointer-events: auto;
    }
    .move-btn {
      width: 60px;
      height: 60px;
      font-size: 24px;
      margin: 5px;
      opacity: 0.7;
      border: none;
      border-radius: 10px;
      background: #444;
      color: #fff;
    }
    #btn-row {
      display: flex;
      justify-content: center;
    }
    #shootButton {
      position: absolute;
      bottom: 20px;
      right: 20px;
      width: 80px;
      height: 80px;
      font-size: 20px;
      border: none;
      border-radius: 50%;
      pointer-events: auto;
      opacity: 0.8;
      background: #b00;
      color: #fff;
    }
  </style>
</head>
<body>
  <div id="hud">
    Health: <span id="health">100</span> |
    Ammo: <span id="ammo">30</span> |
    Score: <span id="score">0</span>
  </div>
  <canvas id="gameCanvas"></canvas>
  
  <!-- Virtual Controls -->
  <div id="controls">
    <div id="movePad">
      <button id="btn-up" class="move-btn">↑</button>
      <div id="btn-row">
        <button id="btn-left" class="move-btn">←</button>
        <button id="btn-down" class="move-btn">↓</button>
        <button id="btn-right" class="move-btn">→</button>
      </div>
    </div>
    <button id="shootButton">Shoot</button>
  </div>

  <script>
    // Get canvas and context
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Global game stats
    let health = 100,
        ammo = 30,
        score = 0;
    
    // Arrays to hold game objects
    const bullets = [];
    const enemyBullets = [];
    const enemies = [];
    const gifts = [];
    const explosions = [];  // For explosion animations

    // Sound effects – ensure these files are in your project folder or update paths accordingly
    const sounds = {
      shoot: new Audio('shoot.mp3'),
      enemyShoot: new Audio('shoot.mp3'),
      gift: new Audio('gift.mp3'),
      explosion: new Audio('explosion.mp3'),
      gameover: new Audio('gameover.mp3')
    };

    // Timing variable for delta time calculation
    let lastTime = performance.now();

    // Update HUD elements
    function updateHUD() {
      document.getElementById('health').textContent = health;
      document.getElementById('ammo').textContent = ammo;
      document.getElementById('score').textContent = score;
    }
    updateHUD();

    // Player object (represented as a circle)
    const player = {
      x: canvas.width / 2,
      y: canvas.height / 2,
      radius: 20,
      speed: 3
    };

    // --- Desktop Input Management ---
    // Keyboard (for movement)
    const keys = {};
    document.addEventListener('keydown', (e) => {
      keys[e.key.toLowerCase()] = true;
      // Reload ammo when pressing 'r'
      if (e.key.toLowerCase() === 'r') {
        ammo = 30;
        updateHUD();
      }
    });
    document.addEventListener('keyup', (e) => {
      keys[e.key.toLowerCase()] = false;
    });

    // Mouse for aiming (desktop)
    const mouse = { x: canvas.width / 2, y: canvas.height / 2 };
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      mouse.x = e.clientX - rect.left;
      mouse.y = e.clientY - rect.top;
      // Update aim direction based on mouse position relative to player
      let dx = mouse.x - player.x;
      let dy = mouse.y - player.y;
      if (dx !== 0 || dy !== 0) {
        aimAngle = Math.atan2(dy, dx);
      }
    });
    // Handle shooting on click (desktop)
    canvas.addEventListener('click', (e) => {
      e.preventDefault();
      fireBullet();
    });

    // --- Virtual Button Controls ---
    // Movement flags for virtual buttons
    let moveUp = false, moveDown = false, moveLeft = false, moveRight = false;
    // Default aiming angle (upward)
    let aimAngle = -Math.PI / 2;

    // Utility function to fire a bullet in the current aim direction
    function fireBullet() {
      if (ammo > 0) {
        const bullet = {
          x: player.x,
          y: player.y,
          radius: 5,
          speed: 7,
          dx: Math.cos(aimAngle) * 7,
          dy: Math.sin(aimAngle) * 7
        };
        bullets.push(bullet);
        ammo--;
        updateHUD();
        sounds.shoot.currentTime = 0;
        sounds.shoot.play();
      }
    }

    // Add event listeners to virtual movement buttons
    function addVirtualButtonListeners(id, onDown, onUp) {
      const btn = document.getElementById(id);
      btn.addEventListener('touchstart', (e) => { e.preventDefault(); onDown(); });
      btn.addEventListener('touchend', (e) => { e.preventDefault(); onUp(); });
      btn.addEventListener('mousedown', (e) => { onDown(); });
      btn.addEventListener('mouseup', (e) => { onUp(); });
      btn.addEventListener('mouseleave', (e) => { onUp(); });
    }

    addVirtualButtonListeners('btn-up', () => { moveUp = true; }, () => { moveUp = false; });
    addVirtualButtonListeners('btn-down', () => { moveDown = true; }, () => { moveDown = false; });
    addVirtualButtonListeners('btn-left', () => { moveLeft = true; }, () => { moveLeft = false; });
    addVirtualButtonListeners('btn-right', () => { moveRight = true; }, () => { moveRight = false; });

    // Add listener for the shoot button
    const shootButton = document.getElementById('shootButton');
    shootButton.addEventListener('touchstart', (e) => { e.preventDefault(); fireBullet(); });
    shootButton.addEventListener('click', (e) => { e.preventDefault(); fireBullet(); });

    // --- Spawn Functions ---
    function spawnEnemy() {
      let x, y;
      const edge = Math.floor(Math.random() * 4); // 0: top, 1: right, 2: bottom, 3: left
      if (edge === 0) {
        x = Math.random() * canvas.width;
        y = -30;
      } else if (edge === 1) {
        x = canvas.width + 30;
        y = Math.random() * canvas.height;
      } else if (edge === 2) {
        x = Math.random() * canvas.width;
        y = canvas.height + 30;
      } else {
        x = -30;
        y = Math.random() * canvas.height;
      }
      const enemy = {
        x: x,
        y: y,
        radius: 20,
        speed: 1.5,
        shootCooldown: Math.random() * 3000 + 2000  // Random cooldown between 2 and 5 seconds
      };
      enemies.push(enemy);
    }

    function spawnGift() {
      const gift = {
        x: Math.random() * (canvas.width - 100) + 50,
        y: Math.random() * (canvas.height - 100) + 50,
        radius: 15
      };
      gifts.push(gift);
      setTimeout(() => {
        const idx = gifts.indexOf(gift);
        if (idx !== -1) gifts.splice(idx, 1);
      }, 10000);
    }

    function createExplosion(x, y) {
      explosions.push({
        x: x,
        y: y,
        radius: 0,
        maxRadius: 40,
        alpha: 1
      });
      sounds.explosion.currentTime = 0;
      sounds.explosion.play();
    }

    // --- Update Function ---
    function update(dt) {
      // --- Update movement from both keyboard and virtual buttons ---
      let dx = 0, dy = 0;
      if (keys['w'] || keys['arrowup'] || moveUp) dy -= 1;
      if (keys['s'] || keys['arrowdown'] || moveDown) dy += 1;
      if (keys['a'] || keys['arrowleft'] || moveLeft) dx -= 1;
      if (keys['d'] || keys['arrowright'] || moveRight) dx += 1;
      if (dx !== 0 || dy !== 0) {
        let mag = Math.hypot(dx, dy);
        dx /= mag;
        dy /= mag;
        // Update aim direction based on movement (if any)
        aimAngle = Math.atan2(dy, dx);
        player.x += dx * player.speed;
        player.y += dy * player.speed;
      }

      // Constrain player within the canvas
      player.x = Math.max(player.radius, Math.min(canvas.width - player.radius, player.x));
      player.y = Math.max(player.radius, Math.min(canvas.height - player.radius, player.y));

      // --- Update bullets ---
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.x += b.dx;
        b.y += b.dy;
        if (b.x < 0 || b.x > canvas.width || b.y < 0 || b.y > canvas.height) {
          bullets.splice(i, 1);
        }
      }

      // --- Update enemy bullets ---
      for (let i = enemyBullets.length - 1; i >= 0; i--) {
        const eb = enemyBullets[i];
        eb.x += eb.dx;
        eb.y += eb.dy;
        if (eb.x < 0 || eb.x > canvas.width || eb.y < 0 || eb.y > canvas.height) {
          enemyBullets.splice(i, 1);
        } else {
          const dist = Math.hypot(player.x - eb.x, player.y - eb.y);
          if (dist < player.radius + eb.radius) {
            enemyBullets.splice(i, 1);
            createExplosion(player.x, player.y);
            health = 0;
            updateHUD();
          }
        }
      }

      // --- Update enemies ---
      for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
        enemy.x += Math.cos(angle) * enemy.speed;
        enemy.y += Math.sin(angle) * enemy.speed;
        enemy.shootCooldown -= dt;
        if (enemy.shootCooldown <= 0) {
          const bulletAngle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
          const enemyBullet = {
            x: enemy.x,
            y: enemy.y,
            radius: 5,
            speed: 5,
            dx: Math.cos(bulletAngle) * 5,
            dy: Math.sin(bulletAngle) * 5
          };
          enemyBullets.push(enemyBullet);
          enemy.shootCooldown = Math.random() * 3000 + 2000;
          sounds.enemyShoot.currentTime = 0;
          sounds.enemyShoot.play();
        }
        const distToPlayer = Math.hypot(player.x - enemy.x, player.y - enemy.y);
        if (distToPlayer < player.radius + enemy.radius) {
          createExplosion(enemy.x, enemy.y);
          enemies.splice(i, 1);
          health = 0;
          updateHUD();
        }
      }

      // --- Update gifts ---
      for (let i = gifts.length - 1; i >= 0; i--) {
        const gift = gifts[i];
        const distToPlayer = Math.hypot(player.x - gift.x, player.y - gift.y);
        if (distToPlayer < player.radius + gift.radius) {
          ammo += 10;
          score += 50;
          updateHUD();
          gifts.splice(i, 1);
          sounds.gift.currentTime = 0;
          sounds.gift.play();
        }
      }

      // --- Check bullet-enemy collisions ---
      for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        for (let j = bullets.length - 1; j >= 0; j--) {
          const bullet = bullets[j];
          const dist = Math.hypot(enemy.x - bullet.x, enemy.y - bullet.y);
          if (dist < enemy.radius + bullet.radius) {
            createExplosion(enemy.x, enemy.y);
            enemies.splice(i, 1);
            bullets.splice(j, 1);
            score += 100;
            updateHUD();
            break;
          }
        }
      }

      // --- Update explosion animations ---
      for (let i = explosions.length - 1; i >= 0; i--) {
        const exp = explosions[i];
        exp.radius += 0.5 * (dt / 16);
        exp.alpha -= 0.02 * (dt / 16);
        if (exp.radius > exp.maxRadius || exp.alpha <= 0) {
          explosions.splice(i, 1);
        }
      }
    }

    // --- Draw Function ---
    function draw() {
      // Dynamic background
      const bgGradient = ctx.createRadialGradient(
        canvas.width / 2, canvas.height / 2, 100,
        canvas.width / 2, canvas.height / 2, canvas.width
      );
      bgGradient.addColorStop(0, '#222');
      bgGradient.addColorStop(1, '#111');
      ctx.fillStyle = bgGradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw dashed aiming line using current aimAngle
      ctx.save();
      ctx.setLineDash([10, 10]);
      ctx.strokeStyle = 'rgba(255,255,255,0.3)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(player.x, player.y);
      const aimLength = 100;
      const aimX = player.x + Math.cos(aimAngle) * aimLength;
      const aimY = player.y + Math.sin(aimAngle) * aimLength;
      ctx.lineTo(aimX, aimY);
      ctx.stroke();
      ctx.restore();

      // Draw player with gradient and shadow
      ctx.save();
      const playerGradient = ctx.createRadialGradient(
        player.x - player.radius / 2,
        player.y - player.radius / 2,
        player.radius / 4,
        player.x,
        player.y,
        player.radius
      );
      playerGradient.addColorStop(0, '#00f');
      playerGradient.addColorStop(1, '#003');
      ctx.fillStyle = playerGradient;
      ctx.shadowColor = 'rgba(0,0,255,0.7)';
      ctx.shadowBlur = 20;
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // Draw bullets with glow
      bullets.forEach(bullet => {
        ctx.save();
        const bulletGradient = ctx.createRadialGradient(
          bullet.x, bullet.y, 0,
          bullet.x, bullet.y, bullet.radius
        );
        bulletGradient.addColorStop(0, '#ff0');
        bulletGradient.addColorStop(1, '#aa0');
        ctx.fillStyle = bulletGradient;
        ctx.shadowColor = 'rgba(255,255,0,0.8)';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });

      // Draw enemy bullets with glow
      enemyBullets.forEach(eb => {
        ctx.save();
        const ebGradient = ctx.createRadialGradient(
          eb.x, eb.y, 0,
          eb.x, eb.y, eb.radius
        );
        ebGradient.addColorStop(0, '#f90');
        ebGradient.addColorStop(1, '#a60');
        ctx.fillStyle = ebGradient;
        ctx.shadowColor = 'rgba(255,140,0,0.8)';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(eb.x, eb.y, eb.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });

      // Draw enemies with fiery glow
      enemies.forEach(enemy => {
        ctx.save();
        const enemyGradient = ctx.createRadialGradient(
          enemy.x, enemy.y, 0,
          enemy.x, enemy.y, enemy.radius
        );
        enemyGradient.addColorStop(0, '#f00');
        enemyGradient.addColorStop(1, '#600');
        ctx.fillStyle = enemyGradient;
        ctx.shadowColor = 'rgba(255,0,0,0.8)';
        ctx.shadowBlur = 20;
        ctx.beginPath();
        ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });

      // Draw gifts with a sparkling effect
      gifts.forEach(gift => {
        ctx.save();
        const giftGradient = ctx.createRadialGradient(
          gift.x, gift.y, 0,
          gift.x, gift.y, gift.radius
        );
        giftGradient.addColorStop(0, '#0f0');
        giftGradient.addColorStop(1, '#060');
        ctx.fillStyle = giftGradient;
        ctx.shadowColor = 'rgba(0,255,0,0.8)';
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.arc(gift.x, gift.y, gift.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });

      // Draw explosion animations
      explosions.forEach(exp => {
        ctx.save();
        ctx.globalAlpha = exp.alpha;
        ctx.fillStyle = 'orange';
        ctx.beginPath();
        ctx.arc(exp.x, exp.y, exp.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });
    }

    // --- Main Game Loop ---
    function gameLoop(currentTime) {
      const dt = currentTime - lastTime;
      lastTime = currentTime;
      update(dt);
      draw();
      if (health > 0) {
        requestAnimationFrame(gameLoop);
      } else {
        gameOver();
      }
    }

    // Game over screen and sound
    function gameOver() {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = 'white';
      ctx.font = '50px Arial';
      ctx.textAlign = 'center';
      ctx.fillText("Game Over", canvas.width / 2, canvas.height / 2);
      ctx.font = '30px Arial';
      ctx.fillText("Score: " + score, canvas.width / 2, canvas.height / 2 + 50);
      sounds.gameover.currentTime = 0;
      sounds.gameover.play();
    }

    // Spawn enemies and gifts at intervals
    setInterval(spawnEnemy, 2000);
    setInterval(spawnGift, 10000);

    // Start the game loop
    requestAnimationFrame(gameLoop);

    // Adjust canvas size when the window is resized
    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });
  </script>
</body>
</html>
